"use server";

import { actionClient } from "@/lib/safe-action";
import {
  addJobSchema,
  addMessageSchema,
  deleteJobSchema,
  deleteMessageSchema,
  editJobSchema,
  editMessageSchema,
} from "@/lib/zod-schema";
import { db } from "@/db";
import { jobs, messages } from "@/schema";
import { auth } from "@clerk/nextjs/server";
import { eq } from "drizzle-orm";
import { GoogleGenAI } from "@google/genai";
import { getJobById, getProfileByUserId } from "@/lib/queries";
import { revalidatePath } from "next/cache";
import { createId } from "@paralleldrive/cuid2";

const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

export const addJob = actionClient
  .inputSchema(addJobSchema)
  .action(async ({ parsedInput: { companyName, jobRole, jobDescription } }) => {
    const { userId } = await auth();
    if (!userId) {
      throw new Error("User not authenticated");
    }

    const insertedJob = await db
      .insert(jobs)
      .values({
        userId,
        companyName,
        jobRole,
        jobDescription,
      })
      .returning()
      .then((res) => res[0]);

    if (!insertedJob?.id) {
      throw new Error("Failed to create job");
    }

    return insertedJob;
  });

export const editJob = actionClient
  .inputSchema(editJobSchema)
  .action(
    async ({ parsedInput: { id, companyName, jobRole, jobDescription } }) => {
      const { userId } = await auth();
      if (!userId) throw new Error("User not authenticated");

      const jobToUpdate = await db.query.jobs.findFirst({
        where: (jobs, { eq }) => eq(jobs.id, id),
      });

      if (!jobToUpdate) throw new Error("Job not found");
      if (jobToUpdate.userId !== userId) throw new Error("Unauthorized");

      const updatedJob = await db
        .update(jobs)
        .set({ companyName, jobRole, jobDescription })
        .where(eq(jobs.id, id))
        .returning()
        .then((res) => res[0]);

      if (!updatedJob) throw new Error("Failed to update job");

      return updatedJob;
    }
  );

export const deleteJob = actionClient
  .inputSchema(deleteJobSchema)
  .action(async ({ parsedInput: { id } }) => {
    const { userId } = await auth();
    if (!userId) throw new Error("User not authenticated");

    const jobToDelete = await db.query.jobs.findFirst({
      where: (jobs, { eq }) => eq(jobs.id, id),
    });

    if (!jobToDelete) throw new Error("Job not found");
    if (jobToDelete.userId !== userId) throw new Error("Unauthorized");

    await db.delete(jobs).where(eq(jobs.id, id));

    return { success: true };
  });

export const addMessage = actionClient
  .inputSchema(addMessageSchema)
  .action(
    async ({
      parsedInput: {
        jobId,
        employeeName,
        employeeRole,
        messageTone,
        customInstructions,
      },
    }) => {
      const { userId } = await auth();
      if (!userId) {
        throw new Error("User not authenticated");
      }

      const job = await getJobById(jobId);
      if (!job) {
        throw new Error("Job not found");
      }

      if (job.userId !== userId) {
        throw new Error(
          "Unauthorized: You don't have permission to access this job"
        );
      }

      const profile = await getProfileByUserId();
      if (!profile) {
        throw new Error("User profile not found");
      }

      const aboutMe = profile?.aboutMe;

      const prompt = `
You are a professional email writer helping someone reach out to company employees for job opportunities. Generate a personalized email message based on the following information:

**Job Information:**
- Company: ${job.companyName}
- Position: ${job.jobRole}
- Job Description: ${job.jobDescription}

**Target Employee:**
- Name: ${employeeName}
- Role: ${employeeRole}

**Sender Information:**
- About Me: ${aboutMe}

**Message Requirements:**
- Tone: ${messageTone}
- Custom Instructions: ${customInstructions || "None provided"}

**Guidelines:**
1. Keep the message professional and respectful
2. Mention specific details about the job and company
3. Show genuine interest in the position
4. Keep it concise (around 200-300 words)
5. Include a clear call to action
6. Use the specified tone: ${messageTone}
7. Address the employee by name and acknowledge their role
8. Don't be overly familiar, maintain professional boundaries

**Format:**
- Subject line first
- Professional email body
- Appropriate closing

Generate a personalized email message that feels authentic and increases the chance of getting a positive response.
`;

      let generatedMessage;
      try {
        const response = await ai.models.generateContent({
          model: "gemini-2.0-flash-001",
          contents: prompt,
        });

        generatedMessage =
          response.text || response.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!generatedMessage) {
          throw new Error("No content generated by AI");
        }
      } catch (error) {
        console.error("AI generation error:", error);
        throw new Error("Failed to generate message content");
      }

      try {
        const messageId = createId();

        const [newMessage] = await db
          .insert(messages)
          .values({
            id: messageId,
            jobId: jobId,
            employeeName: employeeName,
            employeeRole: employeeRole,
            messageTone: messageTone,
            customInstructions: customInstructions || null,
            generatedMessage: generatedMessage,
          })
          .returning();

        revalidatePath(`/job/${jobId}`);

        return {
          success: true,
          data: {
            id: newMessage.id,
            generatedMessage: generatedMessage,
            employeeName: employeeName,
            employeeRole: employeeRole,
            messageTone: messageTone,
            customInstructions: customInstructions,
            createdAt: newMessage.createdAt,
          },
          message: "Message generated and saved successfully",
        };
      } catch (dbError) {
        console.error("Database save error:", dbError);
        throw new Error("Failed to save message to database");
      }
    }
  );

export const deleteMessage = actionClient
  .inputSchema(deleteMessageSchema)
  .action(async ({ parsedInput: { id } }) => {
    const { userId } = await auth();
    if (!userId) throw new Error("User not authenticated");

    const messageToDelete = await db.query.messages.findFirst({
      where: (messages, { eq }) => eq(messages.id, id),
    });

    if (!messageToDelete) throw new Error("Message not found");

    await db.delete(messages).where(eq(messages.id, id));

    return { success: true };
  });

export const editMessage = actionClient
  .inputSchema(editMessageSchema)
  .action(
    async ({
      parsedInput: {
        id,
        jobId,
        employeeName,
        employeeRole,
        messageTone,
        customInstructions,
      },
    }) => {
      const { userId } = await auth();
      if (!userId) {
        throw new Error("User not authenticated");
      }

      // Verify the message exists and belongs to the user
      const existingMessage = await db.query.messages.findFirst({
        where: (messages, { eq }) => eq(messages.id, id),
        with: {
          job: true, // Assuming you have a relation set up
        },
      });

      if (!existingMessage) {
        throw new Error("Message not found");
      }

      // Check if the user owns the job this message belongs to
      const job = await getJobById(jobId);
      if (!job) {
        throw new Error("Job not found");
      }

      if (job.userId !== userId) {
        throw new Error(
          "Unauthorized: You don't have permission to edit this message"
        );
      }

      const profile = await getProfileByUserId();
      if (!profile) {
        throw new Error("User profile not found");
      }

      const aboutMe = profile?.aboutMe;

      // Generate new message with updated information
      const prompt = `
You are a professional email writer helping someone reach out to company employees for job opportunities. Generate a personalized email message based on the following information:

**Job Information:**
- Company: ${job.companyName}
- Position: ${job.jobRole}
- Job Description: ${job.jobDescription}

**Target Employee:**
- Name: ${employeeName}
- Role: ${employeeRole}

**Sender Information:**
- About Me: ${aboutMe}

**Message Requirements:**
- Tone: ${messageTone}
- Custom Instructions: ${customInstructions || "None provided"}

**Guidelines:**
1. Keep the message professional and respectful
2. Mention specific details about the job and company
3. Show genuine interest in the position
4. Keep it concise (around 200-300 words)
5. Include a clear call to action
6. Use the specified tone: ${messageTone}
7. Address the employee by name and acknowledge their role
8. Don't be overly familiar, maintain professional boundaries

**Format:**
- Subject line first
- Professional email body
- Appropriate closing

Generate a personalized email message that feels authentic and increases the chance of getting a positive response.
`;

      let generatedMessage;
      try {
        const response = await ai.models.generateContent({
          model: "gemini-2.0-flash-001",
          contents: prompt,
        });

        generatedMessage =
          response.text || response.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!generatedMessage) {
          throw new Error("No content generated by AI");
        }
      } catch (error) {
        console.error("AI generation error:", error);
        throw new Error("Failed to generate updated message content");
      }

      try {
        const [updatedMessage] = await db
          .update(messages)
          .set({
            employeeName: employeeName,
            employeeRole: employeeRole,
            messageTone: messageTone,
            customInstructions: customInstructions || null,
            generatedMessage: generatedMessage,
            updatedAt: new Date(), // Assuming you have an updatedAt field
          })
          .where(eq(messages.id, id))
          .returning();

        revalidatePath(`/job/${jobId}`);

        return {
          success: true,
          data: {
            id: updatedMessage.id,
            generatedMessage: generatedMessage,
            employeeName: employeeName,
            employeeRole: employeeRole,
            messageTone: messageTone,
            customInstructions: customInstructions,
            updatedAt: updatedMessage.updatedAt,
          },
          message: "Message updated and regenerated successfully",
        };
      } catch (dbError) {
        console.error("Database update error:", dbError);
        throw new Error("Failed to update message in database");
      }
    }
  );
